<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="note&amp;debug">
<meta property="og:type" content="article">
<meta property="og:title" content="精通Spring4.x-chapter4">
<meta property="og:url" content="http://example.com/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter4/index.html">
<meta property="og:site_name" content="A box of chocolates">
<meta property="og:description" content="note&amp;debug">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210420195203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424101012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424110341.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424111347.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424111517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424115855.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210424171309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425192129.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425190742.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425191456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425202233.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425214557.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425222738.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425230558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425230658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210425234229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210426154531.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210426160808.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210426161100.png">
<meta property="og:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210426162033.png">
<meta property="article:published_time" content="2021-05-08T11:20:09.000Z">
<meta property="article:modified_time" content="2021-05-08T11:57:12.621Z">
<meta property="article:author" content="McLaren888">
<meta property="article:tag" content="Spring4.x">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/mclaren8/images/master/20210420195203.png">


<link rel="canonical" href="http://example.com/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter4/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;05&#x2F;08&#x2F;%E7%B2%BE%E9%80%9ASpring4-x-chapter4&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;08&#x2F;精通Spring4-x-chapter4&#x2F;&quot;,&quot;title&quot;:&quot;精通Spring4.x-chapter4&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>精通Spring4.x-chapter4 | A box of chocolates</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">A box of chocolates</h1>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="/uploads/custom-logo.jpg" alt="A box of chocolates">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="McLaren888"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">McLaren888</p>
  <div class="site-description" itemprop="description">It takes a strong man to save himself,and a great man to save another.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kai-soul" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kai-soul" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="McLaren888">
      <meta itemprop="description" content="It takes a strong man to save himself,and a great man to save another.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A box of chocolates">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          精通Spring4.x-chapter4
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-08 19:20:09 / 修改时间：19:57:12" itemprop="dateCreated datePublished" datetime="2021-05-08T19:20:09+08:00">2021-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">note&debug</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在下载Maven依赖包的时候觉得很慢，搜索引擎找到了国内镜像站，设置setting.xml解决</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210420195203.png" alt="photo" /><figcaption>photo</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013058936/article/details/104585376/" class="uri">https://blog.csdn.net/u013058936/article/details/104585376/</a></p>
<p><strong>Bean的概念：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680" class="uri">https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680</a></p>
<p><strong>IoC概念：(Inverse of Control)</strong></p>
<p>控制反转</p>
<p>控制：某一接口具体实现类的选择控制权</p>
<p>反转：将该控制权从调用类中移除，转交给第三方处理</p>
<p><strong>DI：(Dependency Injection)</strong></p>
<p>依赖注入</p>
<p>让调用类对某个接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。</p>
<p>结合书本的个人理解：</p>
<p>拍电影时，剧本中有角色，而角色的具体动作实现需要由具体某位演员实现，因此剧本、角色和演员有很强的耦合性，在实现剧本中某个情节的时候，需要引入角色接口，并创建具体演员。但这样子在每个剧情都要引入角色接口并创建具体演员，这样加大了剧本的剧情创作难度（因为每个剧情都要引入演员，而不是单单只有角色），因此需要有一个导演，来统筹兼顾，在剧本剧情需要的时候，为其注入一个演员。这里的控制便是剧本中的某个剧情要选择某个角色的具体演员的控制权，而反转便是这个选择权交由导演（也就是第三方）来决定，不由编剧决定了。</p>
<p>那么某一接口实现类的选择控制权便是指定具体演员</p>
<p>调用类便是剧本中的剧情</p>
<p>第三方便是导演</p>
<p>即导演选角，导演起到了一个统筹兼顾的重要角色，大大降低了剧本和角色的耦合性，实现解耦</p>
<p>这样也符合我们普遍认知中的投拍流程。</p>
<p>这篇文章可能有助于理解</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/youdutec/p/13393023.html" class="uri">https://www.cnblogs.com/youdutec/p/13393023.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html" class="uri">https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html</a>（防失效）</p>
<p><strong>IoC的类型:</strong></p>
<p>构造函数注入、属性注入和接口注入</p>
<p>Spring支持构造函数注入和属性注入</p>
<p>1、<strong>构造函数注入：</strong></p>
<p>通过调用类的构造函数，将接口实现类通过构造函数变量传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剧本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BEN ben;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MoAttack</span><span class="params">(BEN ben)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ben = ben;		</span><br><span class="line">	&#125;   <span class="comment">//通过构造函数注入BEN的具体饰演者</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ben.responseAsk(<span class="string">&quot;墨者革离&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剧本不关心是谁饰演BEN这个角色，只需要传入演员让其完成具体动作即可</span></span><br><span class="line"><span class="comment">//导演</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//指定角色的饰演者</span></span><br><span class="line">	   BEN ben = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">		<span class="comment">//注入具体饰演者的剧本中</span></span><br><span class="line">	   MoAttack moAttack = <span class="keyword">new</span> MoAttack(ben);</span><br><span class="line">	   moAttack.cityGateAsk();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、属性注入</strong></p>
<p>有时候并不是每个场景都有该角色（主角也没有），因此在具体有需要的场景中注入所需依赖即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> GeLi geli;</span><br><span class="line">  <span class="comment">//属性注入方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGeli</span><span class="params">(GeLi geli)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.geli = geli;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		geli.responseAsk(<span class="string">&quot;墨者革离&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">	   GeLi geli = <span class="keyword">new</span> LiuDeHua();</span><br><span class="line">	   MoAttack moAttack = <span class="keyword">new</span> MoAttack();</span><br><span class="line">	   <span class="comment">//通过属性setGeli方法注入</span></span><br><span class="line">		 moAttack.setGeli(geli);</span><br><span class="line">	   moAttack.cityGateAsk();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、接口注入</strong></p>
<p>将调用类所有依赖注入的方法抽取到一个接口中，调用类通过该接口实现该接口提供相应的注入方法。</p>
<p>因此首先要先声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActorArrangable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(GeLi geli)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后剧本通过调用该接口实现具体要求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span> <span class="keyword">implements</span> <span class="title">ActorArrangable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> GeLi geli;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(GeLi geli)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.geli = geli;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		geli.responseAsk(<span class="string">&quot;墨者革离&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于接口注入需要额外声明一个接口，增加了类的数目，而其效果与属性注入无本质区别，因此一般不使用接口注入</p>
<p><strong>通过容器完成依赖关系的注入</strong></p>
<p>通过第三方使得剧本、导演、演员各司其职，完成解耦。</p>
<p>容器帮助完成类的初始化和装配工作。</p>
<p>Spring通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入工作。</p>
<p>配置文件示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;&lt;http://www.springframework.org/schema/beans&gt;&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;&lt;http://www.w3.org/2001/XMLSchema-instance&gt;&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:p</span>=<span class="string">&quot;&lt;http://www.springframework.org/schema/p&gt;&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;&lt;http://www.springframework.org/schema/beans&gt; </span></span></span><br><span class="line"><span class="tag"><span class="string">       &lt;http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&gt;&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--实现类实例化--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;geli&quot;</span> <span class="attr">class</span>=<span class="string">&quot;LiuDeHua&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;moAttack&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.ioc.MoAttack&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">p:geli-ref</span>=<span class="string">&quot;geli&quot;</span>/&gt;</span> <span class="comment">&lt;!--通过geli-ref建立依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JAVA反射机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">initByDefaultConst</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">				<span class="comment">//通过类装载器获取Car类对象</span></span><br><span class="line">        </span><br><span class="line">				<span class="comment">//获取当前线程的ClassLoader</span></span><br><span class="line">				ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//通过指定的全限定类名“com.xxx...”装载Car类对应的反射实例</span></span><br><span class="line">				Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.smart.reflect.Car&quot;</span>);</span><br><span class="line">				</span><br><span class="line">		</span><br><span class="line">				<span class="comment">//获取类的默认构造器对象并通过它实例化Car</span></span><br><span class="line">        </span><br><span class="line">				<span class="comment">//通过Car的反射类对象获取Car的构造函数对象cons</span></span><br><span class="line">				Constructor&lt;?&gt; cons = clazz.getDeclaredConstructor((Class&lt;?&gt;[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//通过构造函数对象的newInstrance()方法实例化Car对象</span></span><br><span class="line">				Car car = (Car)cons.newInstance();<span class="comment">//效果等同于 new Car()</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//通过反射方法设置属性</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">//通过Car的反射类对象的getMethod(String methodName，Class paramClass)</span></span><br><span class="line">        <span class="comment">//获取属性的setter方法对象，第一个参数为目标Class的方法名，第二个参数时方法入参的对象类型</span></span><br><span class="line">        <span class="comment">//接着通过invoke(Object obj,Object param)方法调用目标类的方法</span></span><br><span class="line">				<span class="comment">//第一个参数为操作的目标类对象实例，第二个参数时目标方法的入参</span></span><br><span class="line">				Method setBrand = clazz.getMethod(<span class="string">&quot;setBrand&quot;</span>,String.class);</span><br><span class="line">        setBrand.invoke(car,<span class="string">&quot;红旗CA72&quot;</span>);</span><br><span class="line">        Method setColor = clazz.getMethod(<span class="string">&quot;setColor&quot;</span>,String.class);</span><br><span class="line">        setColor.invoke(car,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        Method setMaxSpeed = clazz.getMethod(<span class="string">&quot;setMaxSpeed&quot;</span>,<span class="keyword">int</span>.class);</span><br><span class="line">        setMaxSpeed.invoke(car,<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        Car car = initByDefaultConst();</span><br><span class="line">        car.introduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始run时报错，原因是Class、Constructor后面没有加泛型类型，因此加上&lt;?&gt;完成编译运行。</p>
<p>附上链接：</p>
<p>泛型中<T>和&lt;?&gt;有何区别：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jpfss/p/9929045.html" class="uri">https://www.cnblogs.com/jpfss/p/9929045.html</a></p>
<p><strong>类装载器ClassLoader</strong></p>
<p>工作机制：</p>
<p>寻找类的字节码文件并构造出类在JVM内部表示对象的组件。</p>
<p>步骤：</p>
<p>1、装载：查找和导入class文件</p>
<p>2、链接：执行<strong>校验</strong>、<strong>准备</strong>和<strong>解析</strong>步骤，其中<strong>解析</strong>步骤可选</p>
<p>(1)校验：检查载入Class文件数据的正确性</p>
<p>(2)准备：给类的静态变量分配存储空间</p>
<p>(3)解析：将符号引用转换成直接引用</p>
<p>3、初始化：对类的静态变量、静态代码块执行初始化工作</p>
<p>类装载工作由ClassLoader和它的子类负责，JVM在运行时产生个ClassLoader：</p>
<p>根装载器、ExtClassLoader(扩展类装载器)、AppClassLoader(应用类装载器)</p>
<p>其中根装载器不是ClassLoader的子类，使用C++编写，它福着装载JRE的核心类库</p>
<p>ECL负责装载JRE扩展目录ext中的JAR类包，ACL负责装载Classpath路径下的类包，他们都是ClassLoader的子类。</p>
<p>三个装载器存在父子层关系：(从左到右按照父子关系排列) 父装载器</p>
<p>根装载器→ExtClassLoader(扩展类装载器)→AppClassLoader(应用类装载器)</p>
<p>默认情况下，使用ACL装载应用程序的类</p>
<p>JVM装载类时使用“全盘负责委托机制”</p>
<p>“全盘负责”指当一个ClassLoader装载一个类的时候，除非显示地使用另一个ClassLoader，否则该类所依赖及引用的类也由这个ClassLoader载入；</p>
<p>“委托机制”指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类，这样是出于安全目的考虑。否则编写一个恶意的基础类并装载到JVM中，后果很严重。</p>
<p>而“全盘负责委托机制”也会引发一些问题：</p>
<p>在类路径下放置了多个版本的类包，例如commons-lang 2.x.jar和4.x。</p>
<p>如果代码中用到了4.x，而这个方法在2.x中不存在，但JVM又碰巧从2.x中加载类，就会抛出java.lang.NoSuchMethodError的错误。</p>
<p>书本给了一个名为srcAdd.jsp的程序，将其放在Web应用的根路径下，通过</p>
<p><span class="math inline">\(http://localhost/srcAdd.jsp?className=java.net.URL\)</span></p>
<p>可以查看JVM从哪个类包中加载指定类</p>
<p>书本工具还提供了一个ClassLocationUtils.java类，在IDEA断电调试的时候，按下Alt+F8组合键，弹出Evaluate Expression对话框，输入“ClassLocationUtils.where(<类名>.class)”也可以查看</p>
<p>ClassLoader的重要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">loadClass</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//name参数指定装载器需要装载类的名字，注意，必须使用全限定类名，如com.smart.beans.Car</span></span></span><br><span class="line"><span class="function"><span class="comment">//该方法有一个重载方法</span></span></span><br><span class="line"><span class="function">Class <span class="title">loadClass</span><span class="params">(String name,<span class="keyword">boolean</span> resolve)</span></span></span><br><span class="line"><span class="function"><span class="comment">//该方法告诉类装载器是否需要解析该类，如果JVM只需要知道该类是否存在或找出该类的超类，则不需要解析</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class <span class="title">defineClass</span><span class="params">(String name,<span class="keyword">byte</span>[]b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将类文件的字节数组转换成JVM内部的java.lang.Class对象。</span></span></span><br><span class="line"><span class="function"><span class="comment">//字节数组可从本地文件、远程网络获取，参数name为字节数组对应的全限定类名</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class <span class="title">findSystemClass</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//从本地文件载入Class文件，是JVM默认的装载机制</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class <span class="title">findLoadedClass</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//调用该方法来查看是否已经装载某个类，如果已装载，则返回java.lang.Class对象，否则返回null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取类装载器的父装载器</span></span><br></pre></td></tr></table></figure>
<p>JAVA反射类</p>
<p><strong>Constructor：</strong>类的构造函数反射类</p>
<p>通过Class#getConstructors()方法可以活动类的所有构造函数反射对象数组</p>
<p>Constructor的一个主要方法是newInstance(Object[] initargs)，用该方法创建一个对象类的实例，相当于new</p>
<p><strong>Method：</strong>类方法的反射类</p>
<p>通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组</p>
<p>主要方法：invoke(Object obj, Object[] args)， obj表示操作的目标对象；args为方法入参</p>
<p><strong>Field：</strong>类的成员变量的反射类</p>
<p>通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredFields(String name)则可以获取某个特定名称的成员变量反射对象。</p>
<p>主要方法：set(Object obj, Object value), obj表示操作的目标对象，通过value为目标对象的成员变量设置值。如果变量为基础类型，则可以通过setBoolean(Object obj, boolean value)、setInt(Object obj, int value)等设置。</p>
<p>通过反射机制可以绕过限制，查看类的私有变量、调用类的私有方法，但注意要通过方法(变量).setAccessible(boolean access)方法取消Java语言检查。</p>
<p><strong>资源访问利器</strong></p>
<p>资源抽象接口</p>
<p>Spring设计了一个Resource接口，拥有对应不同资源类型的实现类。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>; <span class="comment">//资源是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>; <span class="comment">//资源是否打开</span></span><br><span class="line"></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//如果底层资源可以表示成URL</span></span><br><span class="line">	                               <span class="comment">//则返回对应的URL对象</span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//如果底层资源可以表示成文件</span></span><br><span class="line">                                    <span class="comment">//则返回对应的File对象</span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">//返回资源对应的输入流</span></span><br></pre></td></tr></table></figure>
<p>Spring使用Resource装载各种资源：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424101012.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424101012.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424101012.png</figcaption>
</figure>
<p>WritableResource:可写资源接口，有两个实现类:FileSystemResource 和PathResource</p>
<p>ByteArrayResource:二进制数组表示的资源，二进制数组资源可以在内存中通过程序构造</p>
<p>ClassPathResource ： 类路径下的资源，资源以相对于类路径的方式表示</p>
<p>FileSystemResource :文件系统资源，资源以文件系统路径的方式表示，如D:/kai/bean.xml。</p>
<p>InputStreamResource: 以输入流返回表示的资源</p>
<p>ServletContextResource :为访问Web容器上下文中的资源而设计的类，负责以相对于Web应用根目录的路径加载资源。支持以流和URL的方式访问，在WAR解包的情况下，也可以通过File方式访问。还可以直接通过JAR包访问</p>
<p>UrlResource :URL封装了java.net.URL,它使用户能访问任何通过URL表示的资源，如HTTP、FTP资源等</p>
<p>PathResource: 封装了java.net.URL、java.io.file.Paath、文件系统工资源，可以让用户访问任何可以通过URL、Path、系统文件路径表示的资源，如HTTP、FTP、文件系统的资源。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSourceExample</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String filePath = <span class="string">&quot;G:/masterspring/wangpan/chapter4/src/main/resources/conf/file1.txt&quot;</span>;</span><br><span class="line">			<span class="comment">//使用系统文件路径方式加载文件</span></span><br><span class="line">			WritableResource res1 = <span class="keyword">new</span> PathResource(filePath);</span><br><span class="line">			<span class="comment">//使用类路径方式加载文件</span></span><br><span class="line">			Resource res2 = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;conf/file1.txt&quot;</span>);</span><br><span class="line">			<span class="comment">//使用WritableResource接口写资源文件</span></span><br><span class="line">			OutputStream stream1 = res1.getOutputStream();</span><br><span class="line">			stream1.write(<span class="string">&quot;WHO\\nARE\\nYOU&quot;</span>.getBytes());</span><br><span class="line">			stream1.close();</span><br><span class="line">			<span class="comment">//使用Resource接口读资源文件</span></span><br><span class="line">            InputStream ins1 = res1.getInputStream();</span><br><span class="line">			InputStream ins2 = res2.getInputStream();</span><br><span class="line">			<span class="comment">//二进制输出流</span></span><br><span class="line">			ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="comment">//读取文件内容</span></span><br><span class="line">			<span class="keyword">while</span>((i=ins1.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">				baos.write(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//转换为string类型输出</span></span><br><span class="line">			System.out.println(baos.toString());</span><br><span class="line">   			<span class="comment">//获取资源文件名</span></span><br><span class="line">            System.out.println(<span class="string">&quot;res1:&quot;</span>+res1.getFilename());</span><br><span class="line">            System.out.println(<span class="string">&quot;res2:&quot;</span>+res2.getFilename());            </span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Web应用中，用户可以通过ServletContextResource访问文件资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.web.context.support.ServletContextResource&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.core.io.Resource&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:directive.page <span class="keyword">import</span>=<span class="string">&quot;org.springframework.web.util.WebUtils&quot;</span>/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//注意文件资源地址以相对于Web应用根路径的方式表示</span></span><br><span class="line">   Resource res3 = <span class="keyword">new</span> ServletContextResource(application,<span class="string">&quot;/WEB-INF/classes/conf/file1.txt&quot;</span>);</span><br><span class="line">   out.print(res3.getFilename()+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">   out.print(WebUtils.getTempDir(application).getAbsolutePath());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>资源加载</p>
<p>资源地址表达式:</p>
<p>Spring提供了一些资源类型前缀，可以在不显示使用Resource实现类的情况下，通过这些前缀识别不同的资源类型。</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424110341.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424110341.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424110341.png</figcaption>
</figure>
<p>其中，与<strong>classpath:*<em>对应的还有*</em>classpath*:</strong></p>
<p>假设有多个JAR包或文件系统路径有一个相同的包名。<strong>classpath：</strong>只会在第一个加载的包的类路径下查找，而<strong>classpath*:</strong> 会扫描所有的JAR包及类路径下出现的同样包名的类路径。</p>
<p>例如一个名为kai的应用分为三个模块，一个模块对应一个配置文件，分别为mcl1.xml、mcl2.xml、mcl3.xml，都放在com.smart目录下，每个模块单独打爆成JAR包。</p>
<p>使用<strong>“classpath<em>:com/kai/mcl</em>.xml”</strong>可以加载三个模块的配置文件，而**“classpath:com/kai/mcl*.xml”**只能加载一个模块的配置文件</p>
<p>Ant风格的资源地址支持3种匹配符：</p>
<p>？：匹配文件名中的一个字符</p>
<p>*：匹配文件名中的任意字符</p>
<p>**：匹配多层路径</p>
<p>用法示例：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424111347.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424111347.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424111347.png</figcaption>
</figure>
<p>资源加载器</p>
<p>Spring定义了一套资源加载的接口，并提供了实现类</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424111517.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424111517.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424111517.png</figcaption>
</figure>
<p>注意：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424115855.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424115855.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424115855.png</figcaption>
</figure>
<p><strong>BeanFactory &amp; ApplicationContext</strong></p>
<p>Spring通过一个配置文件描述Bean和Bean之间的依赖关系，利用反射功能实例化Bean并建立Bean之间的依赖关系。</p>
<p>简单划分:BF面向Spring本身而AC面向使用Spring的开发者</p>
<p>BeanFactory</p>
<p>称为IoC容器，可以创建并管理各个种类的对象的通用工厂</p>
<p>类体系结构：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210424171309.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210424171309.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210424171309.png</figcaption>
</figure>
<p>BeanFactory接口：</p>
<p>它通过其他接口不断扩展功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListableBeanFactory <span class="comment">//定义了访问容器中Bean基本信息的若干方法，如查看Bean个数等</span></span><br><span class="line"></span><br><span class="line">HierarchicalBeanFactory <span class="comment">// 父子级联IoC容器的接口，子容器可以通过接口方法访问父容器</span></span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory <span class="comment">//定义了设置类型装载器、属性编辑器、容器初始化后置处理器等方法</span></span><br><span class="line"></span><br><span class="line">AutowireCapableBeanFactory <span class="comment">//定义了将容器中的Bean按某种规则进行自动装配的方法</span></span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry <span class="comment">//定义了允许在运行期间向容器注册单实例Bean的方法</span></span><br><span class="line"></span><br><span class="line">BeanDefinitionRegistry <span class="comment">//提供了向容器手工注册BeanDefinition对象的方法</span></span><br><span class="line">				<span class="comment">//Spring配置文件中每一个&lt;bean&gt;街道元素在Spring容器中通过一个BeanDefinition对象表示</span></span><br><span class="line">		    <span class="comment">//它描述了Bean的配置信息</span></span><br></pre></td></tr></table></figure>
<p>初始化BeanFactory</p>
<p>配置好bean.xml文件后，使用XmlBeanDefinitionReader和DefaultListableBeanFactory启动IOC容器</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425192129.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425192129.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425192129.png</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①下面两句装载配置文件并启动容器</span></span><br><span class="line"> 	   Resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;com/smart/beanfactory/beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">       BeanFactory bf= <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">       XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader((DefaultListableBeanFactory)bf);</span><br><span class="line">       reader.loadBeanDefinitions(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">//④第一次从容器中获取car，将触发容器实例化该Bean，这将引发Bean生命周期方法的调用。</span></span><br><span class="line">       Car car1 = (Car)bf.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">       car1.introduce();</span><br><span class="line">       car1.setColor(<span class="string">&quot;红色&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//⑤第二次从容器中获取car，直接从缓存池中获取</span></span><br><span class="line">       Car car2 = (Car)bf.getBean(<span class="string">&quot;car&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>附上有关getbean()方法说明的链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/01bee649a0c9" class="uri">https://www.jianshu.com/p/01bee649a0c9</a></p>
<p><strong>ApplicationContext</strong></p>
<p>主要实现类：</p>
<p>ClassPathXmlApplicationContext，默认从类路径加载配置文件</p>
<p>FileSystemXmlApplicationContext，默认从文件系统中配置文件</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425190742.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425190742.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425190742.png</figcaption>
</figure>
<p>ApplicationContext初始化：</p>
<p>如果配置文件放在类路径下，使用ClassPathXmlApplicationContext实现类</p>
<p>如果配置文件在文件系统路径，使用FileSystemApplicationContext实现类</p>
<p>还可以指定一组配置文件，Spring会自动将多个配置文件“整合”成一个配置文件</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425191456.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425191456.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425191456.png</figcaption>
</figure>
<p>两种类都可以显示使用带资源类型前缀的路径。</p>
<p>获取实例后，就可以像BeanFactory调用getBean()返回Bean。</p>
<p>BF和AC的初始化有一个区别：</p>
<p>BF在初始化容器时，并未实例化Bean，直到第一次访问某个Bean时才实例化；</p>
<p>而AC在初始化的时候就实例化所有单实例的Bean。</p>
<p>使用类注解的配置方式</p>
<p>使用一个标注@Configuration注解的POJO即可以提供所需的Bean配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beans</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean(name = &quot;car&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">buildCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Car car = <span class="keyword">new</span> Car();</span><br><span class="line">		car.setBrand(<span class="string">&quot;红旗CA72&quot;</span>);</span><br><span class="line">		car.setMaxSpeed(<span class="number">200</span>);</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该配置方法可以让我们很好地控制Bean初始化过程，比XML文件的配置方法更灵活</p>
<p>基于注解类，有一个专门的AC实现类：AnnotationConfigApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//通过一个带@Configuration的POJO装载Bean配置</span></span><br><span class="line">		ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Beans.class);</span><br><span class="line">		<span class="comment">//该方法将加载Beans.class中的Bean定义并调用Beans.class中的方法实例化Bean</span></span><br><span class="line">		Car car =ctx.getBean(<span class="string">&quot;car&quot;</span>,Car.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Groovy DSL 进行Bean定义配置。</p>
<p>基于Groovy的配置提供了专门的AC实现类:GenericGroovyApplicationContext</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425202233.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425202233.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425202233.png</figcaption>
</figure>
<p><debug>在配置groovy文件时，import包时报错“Cannot resolve symbol hibernate”和“... org.springframework.web.servlet”</p>
<p>在pom.xml配置dependency</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springframework.web.servlet在spring-web中--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>WebAC类体系结构</strong></p>
<p>专门为Web应用准备。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境访问Spring应用上下文（WebAC）。</p>
<p>通过一个工具类WebApplicationContextUtils的getWebApplicationContext(ServletContext sc)的方法，从中获取WebAC实例</p>
<p>该方法内部实现方式:</p>
<p>WebAC定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,在AC启动时，WebAC即依次为键放置在ServletContext的属性列表中，通过语句从Web容器中获取WebAC：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425214557.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425214557.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425214557.png</figcaption>
</figure>
<p>这样Spring的Web应用上下文（WebAC）和Web容器的上下文应用（ServletContext）可以实现互访</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425222738.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425222738.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425222738.png</figcaption>
</figure>
<p>看书的时候对Web容器和Spring容器感觉有点混乱，附上一个链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/9371922223/" class="uri">https://www.pianshen.com/article/9371922223/</a></p>
<p>以及对spring上下文、web上下文的区别和联系：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/panxuejun/p/5898540.html" class="uri">https://www.cnblogs.com/panxuejun/p/5898540.html</a></p>
<p>ConfigurableWebApplicationContext扩展了WebAC，它有两个重要方法：</p>
<p>SetServletContext(ServletContext servletcontext)：为spring设置web应用上下文</p>
<p>setConfigLocations(String[] configLocations)：设置Spirng配置文件。一般来说地址是相对于Web根目录的地址，如WEB-INF/smart-dao.xml。但用户也可以用带资源类型前缀的地址，如classpath:com/smart/beans.xml</p>
<p>在非Web应用环境下，Bean中只有singleton和prototype两种作用域</p>
<p>WebAC种添加了三个作用域：request、session、global session</p>
<p><strong>WebAC初始化</strong></p>
<p>它需要ServletContext实例，这个在上面的链接中的spring启动过程可以看到，因此它要在拥有Web容器的前提下才能完成启动工作。</p>
<p>而启动该工作，有两种方式：</p>
<p>一是在web.xml中配置自启动的Servlet</p>
<p>二是在该文件中定义Web容器监听器（ServletContextListener）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定标注了Groovy的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            classpath:conf/spring-mvc.groovy</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ContextLoaderListener监听器将根据上面配置使用</span></span><br><span class="line"><span class="comment">         AnnotationConfigWebApplicationContext根据contextConfigLocation</span></span><br><span class="line"><span class="comment">         指定的配置类启动Spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自启动的Servlet引导：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425230558.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425230558.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425230558.png</figcaption>
</figure>
<p>由于WebAC需要使用日志功能，所以用户将Log4J的配置文件放置在类路径WEB-INF/classes 下，Log4J即可顺利启动。</p>
<p>如果放置在其他位置，则需要在web.xml中指定配置文件的位置。</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425230658.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425230658.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425230658.png</figcaption>
</figure>
<p>注意启动顺序，先装载再初始化</p>
<p>如果使用Web监听器，则要将Log4JConfigListener放置在ContextLoaderListener的前面。该配置方式下，Spring默认使用XmlWebApplicationContext启动Spring容器。</p>
<p>使用标注@Configuration提供配置信息，则web.xml需要按照以下方式配置：</p>
<p>关键是contextClass参数</p>
<p>注意：该段代码按照Groovy DSL配置Bean信息，但实际上与标注java类配置大同小异</p>
<p>只需要在contextClass下改一下support后缀，以及指定标注了@Con...的配置类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过指定context参数，让Spring使用GroovyWebApplicationContext而非</span></span><br><span class="line"><span class="comment">    XmlWebApplicationContext或AnnotationConfigWebApplicationContext启动容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.GroovyWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定标注了Groovy的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            classpath:conf/spring-mvc.groovy</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ContextLoaderListener监听器将根据上面配置使用</span></span><br><span class="line"><span class="comment">         AnnotationConfigWebApplicationContext根据contextConfigLocation</span></span><br><span class="line"><span class="comment">         指定的配置类启动Spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>父子容器</strong></p>
<p>Spring的IoC容器可以建立父子层级关联的容器体系，子容器可以访问父容器的Bean，但父容器无法访问子容器的Bean。</p>
<p>在容器内，Bean的id必须是唯一的，但子容器拥有一个可以和父容器的id相同的bean。</p>
<p>例如在SpringMVC中，展现层Bean位于一个子容器中，而业务层和持久层Bean在父容器中，那么展现层可以引用业务层和持久层，而后两者无法看到展现层</p>
<p><strong>BeanFctory的生命周期</strong></p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210425234229.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210425234229.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210425234229.png</figcaption>
</figure>
<p>具体过程：</p>
<p>（1）调用者通过getBean(beanName)向容器请求某个Bean时，若容器注册了①org.springframework.beans.factory.config.②InstantiationAwareBeanPostProcessor接口，则在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()方法。</p>
<p>（2）根据配置情况调用Bean构造函数或工厂方法实例化Bean。</p>
<p>（3）如果容器注册了②处接口，则在实例化Bean后，调用该接口的postProcessAfterInstantiation()方法，对实例化对象进行修饰。</p>
<p>（4）若Bean设置了属性信息（比如person中的name属性），容器将配置值设置到Bean对应的属性中，不过在设置每个属性之前将先调用②接口的postProcessPropertyValues()方法。</p>
<p>（5）调用Bean的属性设置方法设置属性值</p>
<p>（6）如果Bean实现了①.BeanNameAware接口，则调用setBeanName()接口方法，将配置文件中该Bean对应的名称设置到Bean中。</p>
<p>（7）如果Bean实现了①.BeanFactoryAware接口，则调用setBeanFactory()接口方法，将BeanFactory容器实例设置到Bean中。</p>
<p>（8）如果Bean实现了①.BeanPostProcessor后处理器，则将调用它的Object postProcessBeforeInitialization(Object bean,String beanName)接口方法对Bean进行加工操作。</p>
<p>返回的对象为加工处理后的Bean。</p>
<p>（9）如果Bean实现了InitializingBean接口，则调用接口的afterPropertiesSet()方法</p>
<p>（10）如果在<bean>中通过init-method属性定义了初始化方法，则将执行这个方法。</p>
<p>（11）如果实现了（8），则调用Object postProcessAfterInitialization(Object bean, String beanName)方法，再次对Bean进行加工处理</p>
<p>（12）如果在<bean>中指定Bean的作用范围为scope=&quot;prototype&quot;，则将Bean返回给调用者，调用者负责Bean后续声明管理，Spring不再管理声明周期；如果作用范围设置为&quot;singleton&quot;，则将Bean放入Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对Bean进行后续生命管理。</p>
<p>（13）对应作用范围为“singleton”的Bean（默认），容器关闭时，将除非Spring对Bean后续生命周期的管理工作。如果Bean实现了DisposableBean接口，则将调用接口的destory()方法，可以再次编写释放资源、记录日志等操作。</p>
<p>（14）对应scope=“singleton”的Bean，如果通过<bean>的destroy-method属性指定了Bean的销毁方法，那么SPring将执行这个方法，完成Bean资源的释放等操作。</p>
<p>每个步骤涉及方法的调用，书本将其分为四类：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210426154531.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210426154531.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210426154531.png</figcaption>
</figure>
<p>网上的说明：</p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/e5a68ea453c0f3bdbab14eb384c7ee38.html" class="uri">https://www.huaweicloud.com/articles/e5a68ea453c0f3bdbab14eb384c7ee38.html</a></p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210426160808.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210426160808.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210426160808.png</figcaption>
</figure>
<p>ApplicationContext中Bean的生命周期</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210426161100.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210426161100.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210426161100.png</figcaption>
</figure>
<p>AC和BF另一个最大不同之处：</p>
<p>前者利用JAVA反射机制自动识别出配置文件中定义的BeanPostProcessor、InstantiationAwareBeanPostProcessor和BeanFactoryPostProcessor，并自动将他们注册应用到上下文中，而后者需要在代码中手工调用addBeanPostProcessor()方法进行注册。因此应用开发普遍使用AC而很少用BF</p>
<p>使用工厂后处理器实例：</p>
<figure>
<img src="https://raw.githubusercontent.com/mclaren8/images/master/20210426162033.png" alt="https://raw.githubusercontent.com/mclaren8/images/master/20210426162033.png" /><figcaption>https://raw.githubusercontent.com/mclaren8/images/master/20210426162033.png</figcaption>
</figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>McLaren888
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter4/" title="精通Spring4.x-chapter4">http://example.com/2021/05/08/精通Spring4-x-chapter4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Spring4-x/" rel="tag"># Spring4.x</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter3/" rel="prev" title="精通Spring4.x-chapter3">
                  <i class="fa fa-chevron-left"></i> 精通Spring4.x-chapter3
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/08/%E7%B2%BE%E9%80%9ASpring4-x-chapter5/" rel="next" title="精通Spring4.x-chapter5">
                  精通Spring4.x-chapter5 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">McLaren888</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
